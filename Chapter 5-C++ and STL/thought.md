//关于 UVA 221 Urban Elevation的感触

先来让我们看看什么是离散化

离散化，把无穷空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率
通俗的说，离散化在不改变原有数据的相对大小的条件下，对数据进行缩小
例如：
原数据 1,999,100000,15 处理后变成 1,3,4,2

离散化是程序设计中一个常用的技巧，可以有效的降低时间复杂度，基本思想是在众多可能的情况中，
只考虑需要用的值，离散化可以改进一个低效的算法，甚至不可能实现的算法

//使用 STL 算法离散化
思路是，先排序，再删除重复元素，最后就是索引元素离散化后对应的值

假设待离散化的序列为a[N] ,则对应以上三步为
sort(a,a+n);
int size = unique(a,a+n) - a; //离散化后的元素个数
for(int i = 0; i < n; i++) {
    k = lower_bound(a,a+size,a[i]) - a +1;
}


//无穷转为离散化
这可能是下学期我们要学的离散数学会带来的

思想就是无穷转有限，因为计算机是不可能计算无穷的。

这道题，我们看似要枚举所有的包括的点，这样的话就可以判断一个矩形是否可见
我原先想既然是规则的图形，又是矩形，可不可以枚举4个点
然而其实很容易举出反例，那么其实就是要枚举所有的点了

可是不可能枚举所有的点的
但是我们可以枚举所有的区间，一个区间里面就没有什么部分可见和全部可见的区别了
在这个区间里面只有可能全部可见，那么就只需要枚举一个点，就可以判断可不可见
从而实现了从无穷转为离散化


