<!-- 第一题 -->
定义一个array[10] 起始全部为0
遇到L 从左往右找第一个为0的 设置为1
遇到R 从右往左找第一个为0的 设置为1
遇到数字 相应的array赋值为0

<!-- 第二题 -->
由于拿block不需要时间
因此尽量在达到下一个column的时候拿尽可能多的block
delta 为 max(0,h[i+1]-k) - h[i]
前面是下一个col高度 后面是本次的高度
m-= delta 如果发现减后为0 就是 No

<!-- 第三题 -->
其实由于一段封掉了 因此可以看成在数轴上
两个整数 n,m 令g = gcd(n,m) 
n/g 就是每多少个分为1个区间
m/g 同理 这样我们就可以得到对应的group
若x = 1 那么在(y-1)/(n/g) 区间上
x = 2同理 
如果区间相同的话，那么就说明是可以走到的
做这题的时候认为gcd会超时，不敢用，结果错了
思路是对的，其实gcd很快，不用担心超时，尽管
数据大到10^18方

<!-- 第四题 -->
找到对应的列和行的起始B和终止B
然后滑窗解决问题

做这道题的时候了解到了要找对应列和行的起始B和终止B
但是滑窗问题一直不会导致复杂度增高到O3TLE

在这种情况下学习滑窗很有必要
我们针对以下一维的滑窗
假设滑窗要求选出某三段的max值
数列 1 2 3 4 5 6 7 
那么应该是 1 2 3 
然后加上4减去1
滑窗实际上是加上需要的减去不需要的
这样的话复杂度不会升高
这道题需要O2的复杂度就可以完成

<!-- 第五题 -->



