<-- 第一题 -->
先找到第二个字符串倒序的1的位置
令计时器等于0
第二个字符串去掉第一个字符串的长度倒序找1
每找一次 计时器++
计时器的值为最优解
要字典序最小，就是要尽可能的将第一个字符串的末尾的1给消掉
如果末尾的找不到就找次之末尾的

<-- 第二题 -->
主要是要将每个组合加上 0，1，2，3，4，5，6，7，8，9这样的数字的最小步数找出来
然后就可以遍历字符串然后依次加上最小步数即可


<-- 第三题 -->
偏数学了 上下左右四种，可以撤回一种，但返回的也会受影响
先定义最大的上升 定义最大的下降
然后每次刷新最大上升和下降量
以及可能的上升 - 下降的最大距离
这个每次 上升  - y位置 的最大距离 如果和 y位置 - 下降 的最大距离
相同，那么上下是无用的，就算你W了 那么W也要变成S 作为下降的最大距离
因此这种情况要拉出来判断
其次的话 就是可以选一个最大的距离
左右同理

<-- 第四题 -->
把复杂的Cn2 存入数组
然后从大到小遍历一遍 如果可以减就减掉，其实无形之中  * 2 了
然后一直减掉即可。

for(int i = maxn - 1;i && n; i--) {
            while(n >= a[i]){
                n -= a[i];
                v[++tn] = i; 
            }
        }
        v[tn + 1] = 0;
        for(int i = 1; i<= tn; i++) {
            cout << 1 ;
            for(int j = 0; j < v[i] - v[i + 1]; j++) cout << 3;
        }
        cout << 7 << endl;

while(n >= a[i]) 如果大于等于a[i] 的话 赋值为当前的数
如果减去两个相同的a[i] 那么在j的循环里面会多一次 多打印一个3
即 i * (i - 1) / 2的值 
妙，不过只有在 - 1的时候可能出现减两次的情况
毕竟CN2 数列是  1 3 6 10 15的
可以发现 后面的不可能比前面的两倍大（除了第一项

然后遍历 输出3 本题的关键在于这个3的输出
如果知道 i * cj2 * k = 输入值的话
用求根公式得到的是double没用，应该用这种方法才行
由于cn2 存在 1 因此，一定可以把所有的数都遍历一遍，不会存在某些数没有打印的情况
这里的7其实没有用


<-- 总  结 -->
1.这种题，不太会做，不知道怎么做，多多积累吧。

